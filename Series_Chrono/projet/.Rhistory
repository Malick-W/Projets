#########################
# WADE El Hadji Malick  #
# Master 2 Data Science #
#########################
#########################################################################################
################################ Chargement des données #################################
## On charge les librairies necessaires
library("igraph") # pour le graphe
library('RColorBrewer') # pour les couleurs graphiques
## fournir le chemin absolu des données (2x-2x)
MatIndiv = data.matrix(read.csv("/users/mmath/wade/Bureau/Master_DS/Option_Biologie/Genealogie/Pop2x.csv", header = TRUE, sep = ";"))
n = nrow(MatIndiv) # Nombre d'individus
#########################################################################################
################################ Fonctions ##############################################
## compte le nombre d'enfants virtuels de meme genotype que l'enfant de reference
# in : enfants virtuels (matrice avec un genotype sur chaque ligne), genotype de l'enfant (vecteur)
# out : le nombre d'enfants virtuels correspondant
comparerEnf = function(EnfVirt, Enf){
EnfTri = sort(Enf)
if(is.element(0,EnfTri)){
EnfTri[1] = EnfTri[2]
}
compteur = 0 # Initialisation du compteur du nombre d'enfants virtuels correspondant
for (i in 1:nrow(EnfVirt)){
EnfVirtLTri = sort(EnfVirt[i,])
if(sum(abs(sort(EnfTri) - sort(EnfVirtLTri))) == 0){
compteur = compteur + 1
}
}
return(compteur)
}
## Genere la liste des enfants virtuels a partir du genotype des parents pour le schema 2x-2x
# in : genotype des parents (vecteurs de taille 2)
# out : liste des enfants virtuels (matrice de 4 lignes et 2 colonnes)
genererEnfVirt22 = function(GenP1s, GenP2s){
ListeEnfVirt = matrix(0, nrow = 4, ncol = 2) # Initialisation es 4 enfants virtuels pour le schema 2x-2x
nb = 1
GenP1s = sort(GenP1s)
GenP2s = sort(GenP2s)
# On verifie si l'un des alleles a pour valeur 0, puis on la modifie le cas echeant
if(is.element(0,GenP1s)){
GenP1s[1] = GenP1s[2]
}
if(is.element(0,GenP2s)){
GenP2s[1] = GenP2s[2]
}
# On rajoute chaque croisement d'alleles dans ListeEnfVirt
for (i in GenP1s){
for (j in GenP2s){
ListeEnfVirt[nb,] = c(i,j)
nb = nb + 1
}
}
return(ListeEnfVirt)
}
## calcul de la proba d'un lien entre deux parents et un enfant
# in : infos genetiques sur les deux parents et l'enfant (vecteurs de taille 17 : genotypes 4x4 + ploidie)
# out : proba du lien
calculerProbaLien = function(GenP1, GenP2, GenE){
plo1 = GenP1[17] # ploidie du parent 1
plo2 = GenP2[17] # ploidie du parent 2
ploE = GenE[17] # ploidie de l'enfant
# Traiter seulement 2x-2x dans un premier temps (recuperer les ploidies et rentrer seulement si toutes sont egales a 2)
if((plo1 == 2) & (plo2 == 2) & (ploE == 2)){
proba = 1 # Initialisation de la probabilite
# Boucler sur les 4 signaux en multipliant la variable proba par la nouvelle probabilite
for (signal in 1:4){
GenP1sign = GenP1[(1:4)+(signal-1)*4]
GenP2sign = GenP2[(1:4)+(signal-1)*4]
GenEsign = GenE[(1:4)+(signal-1)*4]
# Creer des vecteurs de taille 2 avec les alleles des parents et de l'enfant sur le signal
G1 = GenP1sign[1:2]
G2 = GenP2sign[1:2]
GE = GenEsign[1:2]
# Generer les enfants virtuels du croisement, comparer avec l'enfant et deduire la proba
ListeEnfVirt = genererEnfVirt22(G1,G2)
nbMatch = comparerEnf(ListeEnfVirt,GE)/4
proba = nbMatch*proba
}
}
else{
proba = 0
}
return(proba)
}
## construit pour un enfant la matrice des probas associee a tous les couples de parents potentiels
# in : numero de l'enfant
# out : matrice des probas (n lignes et n colonnes)
calculerProbasParents = function(enfant){
MatProbasParents = matrix(0, nrow = n, ncol = n) # Initialisation de la matrice = 0
for (i in 1:(n-1)){
for (j in (i+1):n){
if ((i != j) & (i != enfant) & (j != enfant) & (MatIndiv[i,18] < MatIndiv[enfant,18]) & (MatIndiv[j,18] < MatIndiv[enfant,18])){
proba = calculerProbaLien(MatIndiv[i,1:17],MatIndiv[j,1:17],MatIndiv[enfant,1:17])
MatProbasParents[i,j] = proba
}
}
}
sommeProba = sum(MatProbasParents)
if (sommeProba != 0){
MatProbasParents = MatProbasParents/sommeProba
}
return(MatProbasParents)
}
## Recherche du couple de parents le plus probable pour un enfant
# in : numero de l'enfant
# out : couple de parents le plus probable (vecteur de taille 4 : enfant/parent 1/parent 2/log-proba du lien)
recupParentsMax = function(e){
ParentsMax = c(e,0,0,0) # Initialisation de ParentsMax
MatProbasParents = calculerProbasParents(e)
pmax = max(MatProbasParents)
if(pmax != 0){
IndMax = which(MatProbasParents == pmax, arr.ind = TRUE)
# Par convention : mettre 0-0 pour les parents si toutes les probas sont nulles, et 0 dans la case log-proba
ParentsMax[2] = IndMax[1,1]
ParentsMax[3] = IndMax[1,2]
ParentsMax[4] = log(pmax)
}
return(ParentsMax)
}
## Construit la genealogie de plus grande proba associee a la matrice des individus
# in : rien
# out : genealogie la plus probable (matrice de n lignes et 4 colonnes) munie de la log-vraisemblance
construireGen = function(){
Gen = matrix(0, nrow = n, ncol = 4)
for(individu in 1:n){
p = recupParentsMax(individu)
Gen[individu,] = p
}
return(list(Gen = Gen, lLik = sum(Gen[,4])))
}
#########################################################################################
################################ Contruction du graphe #################################
## Construit le graphe généalogique associé aux données
representerGen = function(GenMax){
nodes = data.frame(id=GenMax$Gen[,1], gen=MatIndiv[,18])
links = data.frame()
for (i in 1:n) {
if (GenMax$Gen[i,2] != 0 & GenMax$Gen[i,3] != 0){
link1 = data.frame(from=GenMax$Gen[i,2],
to=GenMax$Gen[i,1],
weight=round(exp(GenMax$Gen[i,4]),2))
link2 = data.frame(from=GenMax$Gen[i,3],
to=GenMax$Gen[i,1],
weight=round(exp(GenMax$Gen[i,4]),2))
links = rbind(links,link1,link2)
}
}
net = graph_from_data_frame(d=links, vertices=nodes, directed=TRUE)
net
nombre_de_generation = max(MatIndiv[,18])
#colrs = rainbow(nombre_de_generation, alpha=.5)
colrs = brewer.pal(nombre_de_generation, "Set3")
# Attribuer des couleurs selon le type de média
V(net)$color = colrs[V(net)$gen]
V(net)$size = 12
V(net)$label.font = 4  #Fonte : 1 normal, 2 gras, 3, italique, 4 italique gras, 5 symbole
V(net)$label.color = "black"
V(net)$label.family = "Times"
# Épaisseur des liens fonction de l'intensité
E(net)$width = E(net)$weight*4
# Changer la taille des flèches et la couleur des liens
E(net)$arrow.size = 0.6 #Taille des fléches, 1 par défaut
E(net)$arrow.width = 1.5 #Épaisseur des flèches, 1 par défaut
E(net)$edge.lty = 3 #Type de ligne
E(net)$label = E(net)$weight #Vecteur de type caractère utilisé pour nommer les liens
E(net)$edge.label.family = "Helvetica" #Police des labels (e.g.“Times”, “Helvetica”)
#E(net)$label.color = "black"
E(net)$edge.label.cex = 0.1 #Taille de la police pour les labels des liens
E(net)$edge.color = "gray80"
E(net)$edge.label = E(net)$weight
plot(net, main ="Genealogie de la diploidie")
legend("bottomleft", inset = 0.001, title="génération", legend = 1:nombre_de_generation, pch=21,
text.font=4, col="#777777", pt.bg=colrs, pt.cex=1, cex=.6, bty="n", ncol=1)
}
#########################################################################################
################################# Application ###########################################
GenMax = construireGen()
representerGen(GenMax)
## Documentation sur les graphes
#https://f.hypotheses.org/wp-content/blogs.dir/2996/files/2017/02/visualiseR.pdf
setwd("~/Bureau/Projets/Series_Chrono/projet")
path_Conso = "/users/mmath/wade/Bureau/Projets_Malick_fayad/Series_Chrono_Malick_fayad/projet/Conso.RData"
path_Temp = "/users/mmath/wade/Bureau/Projets_Malick_fayad/Series_Chrono_Malick_fayad/projet/Temp.RData"
load(path_Conso)
load(path_Temp)
LConso = log(Conso)
# trace des donnees
plot(Conso, type="l", xlab="temps(Heure)", ylab="Consommation")
plot(LConso, type="l", xlab="temps(Heure)", ylab="Log_Consommation")
# trace des donnees
plot(Temp, type="l",xlim=c(1,96), xlab="temps(Heure)", ylab="Température")
plot(Temp[1:1500], Conso[1:1500], main="The Sine Function", xlab="temp(Heure)", ylab="Conso")
# objectif : modeliser la serie logarithmique par un modele additif et effectuer une prediction sur l'annee suivante
# autocorrelations empiriques de la series
acf(Conso, main="ACF empirique")
# notre choix se porte sur une periode de 12
# (une periode de 6 peut etre retenue mais l'experience montre qu'elle ne permet pas de rendre la serie aperiodique)
tau = 24
m = tau/2
nsup = length(Conso)%%tau
n = length(Conso)-nsup # on se ramene a un nombre entier de periodes (a eviter lorsque les donnees sont rares)
ResConso = Conso[(n+1):length(Conso)]
Conso = Conso[1:n]
ResConso = Conso[(n+1):(n+nsup)]
Conso = Conso[1:n]
# filtrage par moyenne mobile arithmetique modifiee d'ordre 6
MMConso = rep(0, n-2*m)
for (i in 1:(n-2*m)){
MMConso[i] = (Conso[i] + Conso[i+2*m])/(4*m) + sum(Conso[(i+1):(i+2*m-1)])/(2*m)
}
# representation de la serie filtree : elle est visuellement aperiodique
plot(MMConso, type="l", xlab="t", ylab="Log Ventes apres moyenne mobile")
# il existe manifestement une tendance, pour l'estimer on retient 4 modeles :
# - M1 : une regression lineaire sur {1, t, t^2} pour la forme parabolique, estimee sans memoire du bruit (OLS)
# - M2 : une regression lineaire sur {1, t}, estimee sans memoire du bruit (OLS)
# - M3 : une regression lineaire sur {1, t, t^2}, estimee avec un bruit a courte memoire (GLS-MA(1))
# - M4 : une regression lineaire sur {1, t, t^2}, estimee avec un bruit a longue memoire (GLS-AR(1))
# espace des temps observables (prive des m premieres et dernieres valeurs)
Tps = 1:(n-2*m)
Tps2 = Tps^2
# M1
RegLinM1 = lm(MMConso ~ 1+Tps+Tps2)
summary(RegLinM1)
b0M1 = RegLinM1$coefficients[1]
b1M1 = RegLinM1$coefficients[2]
b2M1 = RegLinM1$coefficients[3]
lines(b0M1 + b1M1*Tps + b2M1*Tps2, type="l", col="red")
# M2
RegLinM2 = lm(MMConso ~ 1+Tps)
summary(RegLinM2)
b0M2 = RegLinM2$coefficients[1]
b1M2 = RegLinM2$coefficients[2]
lines(b0M2 + b1M2*Tps, type="l", col="blue")
# package pour les GLS
library("nlme")
# M3
RegLinGenM3 = gls(MMConso ~ 1+Tps+Tps2, correlation = corARMA(p=0, q=1))
b0M3 = RegLinGenM3$coefficients[1]
b1M3 = RegLinGenM3$coefficients[2]
b2M3 = RegLinGenM3$coefficients[3]
lines(b0M3 + b1M3*Tps + b2M3*Tps2, type="l", col="magenta")
# M4
RegLinGenM4 = gls(MMConso ~ 1+Tps+Tps2, correlation = corARMA(p=1, q=0))
b0M4 = RegLinGenM4$coefficients[1]
b1M4 = RegLinGenM4$coefficients[2]
b2M4 = RegLinGenM4$coefficients[3]
lines(b0M4 + b1M4*Tps + b2M4*Tps2, type="l", col="forestgreen")
# pour chacun des modeles, on recupere l'estimation de la tendance sur tout l'espace des temps
EstM1 = b0M1 + b1M1*(1:n) + b2M1*(1:n)^2
EstM2 = b0M2 + b1M2*(1:n)
EstM3 = b0M3 + b1M3*(1:n) + b2M3*(1:n)^2
EstM4 = b0M4 + b1M4*(1:n) + b2M4*(1:n)^2
# superposition du signal et de la tendance estimee
plot(Conso, type="l", xlab="t", ylab="Log Ventes")
lines(EstM1, type="l", col="red")
lines(EstM2, type="l", col="blue")
lines(EstM3, type="l", col="magenta")
lines(EstM4, type="l", col="forestgreen")
# recuperation du signal prive de sa tendance, pour estimer la saisonnalite
SaisM1 = Conso - EstM1
SaisM2 = Conso - EstM2
SaisM3 = Conso - EstM3
SaisM4 = Conso - EstM4
# representation des signaux prives de leur tendance
plot(SaisM1, type="l", xlab="t", ylab="Log Ventes sans tendance", col="red")
lines(SaisM2, type="l", col="blue")
lines(SaisM3, type="l", col="magenta")
lines(SaisM4, type="l", col="forestgreen")
# le motif periodique est un vecteur de taille 12
MotifM1 = rep(0, tau)
MotifM2 = rep(0, tau)
MotifM3 = rep(0, tau)
MotifM4 = rep(0, tau)
# on moyennise toutes les periodes extraites des signaux
for (k in 1:tau){
Extr = SaisM1[seq(k, n, by=tau)]
MotifM1[k] = mean(Extr)
Extr = SaisM2[seq(k, n, by=tau)]
MotifM2[k] = mean(Extr)
Extr = SaisM3[seq(k, n, by=tau)]
MotifM3[k] = mean(Extr)
Extr = SaisM4[seq(k, n, by=tau)]
MotifM4[k] = mean(Extr)
}
# on recentre le motif pour qu'il satisfasse la contrainte d'identifiabilite du modele
MotifM1 = MotifM1 - mean(MotifM1)
MotifM2 = MotifM2 - mean(MotifM2)
MotifM3 = MotifM3 - mean(MotifM3)
MotifM4 = MotifM4 - mean(MotifM4)
# representation des motifs periodiques estimes
plot(MotifM1, type="l", xlab="t", ylab="Motif periodique", col="red")
lines(MotifM2, type="l", col="blue")
lines(MotifM3, type="l", col="magenta")
lines(MotifM4, type="l", col="forestgreen")
# estimation de la saisonnalite par duplication du motif
EstSaisM1 = rep(MotifM1, n/tau)
EstSaisM2 = rep(MotifM2, n/tau)
EstSaisM3 = rep(MotifM3, n/tau)
EstSaisM4 = rep(MotifM4, n/tau)
# superposition du signal et de la somme de la tendance et de la saisonnalite estimees
plot(Conso, type="l", xlab="t", ylab="Log Ventes")
lines(EstM1+EstSaisM1, type="l", col="red")
lines(EstM2+EstSaisM2, type="l", col="blue")
lines(EstM3+EstSaisM3, type="l", col="magenta")
lines(EstM4+EstSaisM4, type="l", col="forestgreen")
# recuperation de la fluctuation residuelle
ResM1 = Conso - EstM1 - EstSaisM1
ResM2 = Conso - EstM2 - EstSaisM2
ResM3 = Conso - EstM3 - EstSaisM3
ResM4 = Conso - EstM4 - EstSaisM4
# calcul de l'erreur MSE commise lorsqu'on estime le signal par la somme de sa tendance et de sa saisonnalite
MSEM1 = mean((ResM1)^2)
MSEM2 = mean((ResM2)^2)
MSEM3 = mean((ResM3)^2)
MSEM4 = mean((ResM4)^2)
# le modele M4 semble le meilleur, au sens de ce critere
# au contraire, le modele M2 semble le moins bon, ce qui etait attendu (la droite est clairement moins adaptee que la parabole pour modeliser la tendance)
# autocorrelations empiriques des residus pour detecter des correlations et/ou une saisonnalite non eliminee
acf(ResM1, main="ACF empirique")
acf(ResM2, main="ACF empirique") # presence de correlations ici, raison supplementaire pour rejeter le modele M2 par rapport aux autres
acf(ResM3, main="ACF empirique")
acf(ResM4, main="ACF empirique")
# on souhaite predire l'annee suivante
NTps = (n+1):(n+tau)
PredM1 = b0M1 + b1M1*NTps + b2M1*NTps^2 + MotifM1
PredM2 = b0M2 + b1M2*NTps + MotifM2
PredM3 = b0M3 + b1M3*NTps + b2M3*NTps^2 + MotifM3
PredM4 = b0M4 + b1M4*NTps + b2M4*NTps^2 + MotifM4
# representation du signal et de nos previsions par les 4 modeles
plot(1:n, Conso, type="l", xlab="t", ylab="Log Ventes", xlim=c(1, n+tau))
lines((n+1):(n+nsup), ResConso, type="l", col="black", lty=2)
lines(NTps, PredM1, type="l", col="red")
lines(NTps, PredM2, type="l", col="blue")
lines(NTps, PredM3, type="l", col="magenta")
lines(NTps, PredM4, type="l", col="forestgreen")
# representation du signal initial et de nos previsions par les 4 modeles
plot(1:n, Conso, type="l", xlab="t", ylab="Ventes", xlim=c(1, n+tau))
lines((n+1):(n+nsup), ResConso, type="l", col="black", lty=2)
lines(NTps, exp(PredM1), type="l", col="red")
lines(NTps, exp(PredM2), type="l", col="blue")
lines(NTps, exp(PredM3), type="l", col="magenta")
lines(NTps, exp(PredM4), type="l", col="forestgreen")
# notre etude montre que la prevision par M4 semble la plus pertinente
# remarque : on verra dans la suite du cours qu'il n'est pas necessairement pertinent de predire exp(Conso) par exp(Prediction)
# on illustre pour conclure l'application de la procedure "decompose" qui realise la modelisation additive
ConsoTS = ts(Conso, frequency=tau)
Decomp = decompose(ConsoTS)
plot(Decomp)
# comparaison entre le motif periodique issu de "decompose" et celui de notre meilleur modele
plot(Decomp$figure, xlab="t", ylab="Motif periodique", type="l")
lines(MotifM4, col="forestgreen")
# plus rapide ?
# par contre, R n'estime pas la tendance : donc, pas de prediction !
path_Conso = "/users/mmath/wade/Bureau/Projets_Malick_fayad/Series_Chrono_Malick_fayad/projet/Conso.RData"
path_Temp = "/users/mmath/wade/Bureau/Projets_Malick_fayad/Series_Chrono_Malick_fayad/projet/Temp.RData"
load(path_Conso)
load(path_Temp)
LConso = log(Conso)
